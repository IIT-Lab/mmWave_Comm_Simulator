
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>3GPP 5G NR PDSCH Throughput Simulation</title><meta name="generator" content="MATLAB 9.4"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2018-02-12"><meta name="DC.source" content="NewRadio5GLinkExample.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><style>
.open_example { 
    padding:0px 0px 1px 0px;
    margin:20px;
    font-size:0.9em;
    border:1px solid #aeaeae;
    display:block;
    float:right;
    border-radius:5px; -moz-border-radius:5px; -webkit-border-radius:5px;
    background: #ffffff; /* Old browsers */
    background: -moz-linear-gradient(top, #FFFFFF 0%, #E6E6E6 100%); /* FF3.6+ */	
    background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#FFFFFF), color-stop(100%,#E6E6E6)); /* Chrome,Safari4+ */
    background: -webkit-linear-gradient(top, #FFFFFF 0%,#E6E6E6 100%); /* Chrome10+,Safari5.1+ */
    background: -o-linear-gradient(top,  #ffffff 0%,#e6e6e6 100%); /* Opera 11.10+ */
    background: -ms-linear-gradient(top,  #ffffff 0%,#e6e6e6 100%); /* IE10+ */
    background: linear-gradient(top,  #ffffff 0%,#e6e6e6 100%); /* W3C */
    filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#FFFFFF', endColorstr='#E6E6E6',GradientType=0 ); /* IE6-9 */
}

.open_example:hover {
    background: #f3f3f3; /* Old browsers */
    background: -moz-linear-gradient(top, #f3f3f3 0%, #d7d7d7 100%); /* FF3.6+ */    
    background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#f3f3f3), color-stop(100%,#d7d7d7)); /* Chrome,Safari4+ */
    background: -webkit-linear-gradient(top, #f3f3f3 0%,#d7d7d7 100%); /* Chrome10+,Safari5.1+ */
    background: -o-linear-gradient(top,  #f3f3f3 0%,#d7d7d7 100%); /* Opera 11.10+ */
    background: -ms-linear-gradient(top,  #f3f3f3 0%,#d7d7d7 100%); /* IE10+ */
    background: linear-gradient(top,  #f3f3f3 0%,#d7d7d7 100%); /* W3C */
    filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#f3f3f3', endColorstr='#d7d7d7',GradientType=0 ); /* IE6-9 */
} 

.open_example a { 
    padding:6px 10px; 
    line-height:130%;
    text-decoration:none;
    float:left;
}
      </style><div class="open_example"><a href="matlab:edit NewRadio5GLinkExample">Open this Example</a></div><div class="content"><h1>3GPP 5G NR PDSCH Throughput Simulation</h1><!--introduction--><p>This example measures the PDSCH throughput of a 5G link, as defined by the 3GPP NR standard. The example supports the 5G NR DL-SCH, PDSCH precoding, and 5G subcarrier spacings and bandwidths. The transmitter model includes 5G PDSCH DM-RS and SS burst. Both CDL and TDL propagation channels are supported.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Introduction</a></li><li><a href="#2">Simulation Length and SNR Points</a></li><li><a href="#3">gNodeB and PDSCH Configuration</a></li><li><a href="#6">Propagation Channel Model Configuration</a></li><li><a href="#9">Reserve PDSCH Resources Corresponding to SS burst</a></li><li><a href="#10">Processing Loop</a></li><li><a href="#11">Results</a></li><li><a href="#13">Appendix</a></li><li><a href="#14">Selected Bibliography</a></li></ul></div><h2 id="1">Introduction</h2><p>This example measures the PDSCH throughput of a 5G link, as defined by the 3GPP NR standard V15.0 [ <a href="#14">1</a> ], [ <a href="#14">2</a> ], [ <a href="#14">3</a> ], [ <a href="#14">4</a> ].</p><p>The following 5G NR features are implemented:</p><div><ul><li>5G DL-SCH transport channel coding</li><li>5G PDSCH DM-RS generation</li><li>SS burst generation (PSS/SSS/PBCH/PBCH DM-RS)</li><li>NR subcarrier spacing and frame numerologies (2^n * 15kHz) for normal and extended cyclic prefix</li><li>Support for 5G bandwidths</li><li>5G CP-OFDM, with the option of W-OFDM (WOLA-OFDM) and F-OFDM (Filtered OFDM)</li><li>TDL and CDL propagation channel models</li></ul></div><p>The main features of the simulation are:</p><div><ul><li>DL-SCH can be switched between 5G NR (LDPC) and LTE (turbo)</li><li>PDSCH non-codebook based precoding using SVD</li><li>Slot wise and non slot wise PDSCH and DM-RS mapping</li><li>SS burst generation (cases A-E, SS/PBCH block bitmap control)</li><li>NR subcarrier spacings and frame numerologies</li><li>CP-OFDM, F-OFDM and WOLA-OFDM waveform selection</li><li>TDL or CDL channel selection</li><li>Perfect synchronization and channel estimation</li></ul></div><p>The figure below shows the processing chain implemented. For clarity, the DM-RS and SS burst generation have been omitted.</p><p><img vspace="5" hspace="5" src="5GAddOnExampleProcessingChain.png" alt=""> </p><p>Note that perfect synchronization and perfect channel knowledge are assumed, i.e. SS/PBCH block and PDSCH DM-RS signals are not used at the receiver. In this example, the PDSCH implementation uses the LTE PDSCH configured for non-codebook based precoding and LTE PDSCH scrambling. A single precoding matrix for the whole PDSCH allocation is determined using SVD by averaging the channel estimate across all allocated PDSCH PRBs. Therefore for large PDSCH allocations i.e. occupying a wide bandwidth, the single precoding matrix may not be well matched to the channel across all frequencies, resulting in performance degradation. There is no beamforming on the SS/PBCH blocks in the SS burst.</p><h2 id="2">Simulation Length and SNR Points</h2><p>Set the length of the simulation in terms of the number of 10ms frames. Set the SNR points to simulate.</p><pre class="codeinput">simParameters = [];             <span class="comment">% Clear simParameters variable</span>
simParameters.NFrames = 2;      <span class="comment">% Number of 10ms frames</span>
simParameters.SNRIn = [-5 0 5]; <span class="comment">% SNR range</span>
</pre><h2 id="3">gNodeB and PDSCH Configuration</h2><p>Set the key parameters of the simulation. These include:</p><div><ul><li>The bandwidth in resource blocks (12 subcarriers per resource block).</li><li>Subcarrier spacing: 15, 30, 60, 120, 240, 480 (kHz)</li><li>Waveform: 'CP-OFDM', 'F-OFDM' or 'W-OFDM'</li><li>DC subcarrier flag</li></ul></div><p>A substructure containing the DL-SCH and PDSCH parameters is also specified. This includes:</p><div><ul><li>Target code rate</li><li>Transport channel coding: 'LDPC', 'Turbo'</li><li>Allocated resource blocks (PRBSet)</li><li>Modulation scheme: 'QPSK', '16QAM', '64QAM', '256QAM'</li><li>Number of layers</li><li>Number of transmit antennas</li><li>PDSCH mapping type</li><li>DM-RS configuration parameters</li></ul></div><p>Other simulation wide parameters are:</p><div><ul><li>Propagation channel model: 'TDL' or 'CDL'</li><li>Number of receive antennas</li><li>SS burst configuration parameters. Note that the SS burst generation can be disabled by setting the <tt>SSBTransmitted</tt> field to [0 0 0 0].</li></ul></div><pre class="codeinput"><span class="comment">% Set waveform type and PDSCH numerology (SCS and CP type)</span>
simParameters.NDLRB = 100;               <span class="comment">% Bandwidth in number of resource blocks (20MHz at 15kHz SCS)</span>
simParameters.SubcarrierSpacing = 15;    <span class="comment">% 15, 30, 60, 120, 240, 480 (kHz)</span>
simParameters.WaveformType = <span class="string">'CP-OFDM'</span>;  <span class="comment">% 'CP-OFDM', 'W-OFDM' or 'F-OFDM'</span>
simParameters.CyclicPrefix = <span class="string">'Normal'</span>;   <span class="comment">% 'Normal' or 'Extended'</span>
simParameters.UseDCSubcarrier = <span class="string">'On'</span>;    <span class="comment">% 'On' or 'Off'</span>
simParameters.NCellID = 1;               <span class="comment">% Cell identity</span>

<span class="comment">% DL-SCH/PDSCH parameters</span>
simParameters.PDSCH.TargetCodeRate = 0.5;    <span class="comment">% Code rate used to calculate transport block sizes</span>
simParameters.PDSCH.CodingType = <span class="string">'LDPC'</span>;     <span class="comment">% Set to 'LDPC' for 5G DL-SCH or 'Turbo' for LTE DL-SCH</span>
simParameters.PDSCH.PRBSet = 8:15;           <span class="comment">% PDSCH PRB allocation</span>
simParameters.PDSCH.SymbolSet = 0:13;        <span class="comment">% PDSCH symbol allocation in slot</span>
simParameters.PDSCH.Modulation = <span class="string">'16QAM'</span>;    <span class="comment">% 'QPSK', '16QAM', '64QAM', '256QAM'</span>
simParameters.PDSCH.NLayers = 2;             <span class="comment">% Number of PDSCH layers</span>
simParameters.PDSCH.NTxAnts = 8;             <span class="comment">% Number of PDSCH transmission antennas</span>
simParameters.PDSCH.EnableHARQ = true;       <span class="comment">% Enable/disable HARQ, if disabled, single transmission with RV=0, i.e. no retransmissions</span>
<span class="comment">% DM-RS configuration (TS 38.211 section 7.4.1.1)</span>
simParameters.PDSCH.PortSet = [0,2];         <span class="comment">% DM-RS ports to use for the layers</span>
simParameters.PDSCH.PDSCHMappingType = <span class="string">'A'</span>;  <span class="comment">% PDSCH mapping type ('A'(slot-wise),'B'(non slot-wise))</span>
simParameters.PDSCH.DL_DMRS_typeA_pos = 2;   <span class="comment">% Mapping type A only. First DM-RS symbol position (2,3)</span>
simParameters.PDSCH.DL_DMRS_max_len = 1;     <span class="comment">% Number of front-loaded DM-RS symbols (1(single symbol),2(double symbol))</span>
simParameters.PDSCH.DL_DMRS_add_pos = 0;     <span class="comment">% Additional DM-RS symbol positions (max range 0...3)</span>
simParameters.PDSCH.DL_DMRS_config_type = 2; <span class="comment">% DM-RS configuration type (1,2)</span>
simParameters.PDSCH.NIDNSCID = 1;            <span class="comment">% Scrambling identity (0...65535)</span>
simParameters.PDSCH.NSCID = 0;               <span class="comment">% Scrambling initialization (0,1)</span>
<span class="comment">% Reserved PRB patterns (for CORESETs, forward compatibility etc)</span>
simParameters.PDSCH.Reserved.Symbols = [];   <span class="comment">% Reserved PDSCH symbols</span>
simParameters.PDSCH.Reserved.PRB = [];       <span class="comment">% Reserved PDSCH PRBs</span>
simParameters.PDSCH.Reserved.Period = [];    <span class="comment">% Periodicity of reserved resources</span>

<span class="comment">% Define the propagation channel type and number of receive antennas</span>
simParameters.ChannelType = <span class="string">'CDL'</span>; <span class="comment">% 'CDL' or 'TDL'</span>
simParameters.NRxAnts = 2;         <span class="comment">% Number of receive antennas at UE</span>

<span class="comment">% SS burst configuration</span>
simParameters.SSBurst.BurstType = <span class="string">'CaseB'</span>;        <span class="comment">% 30kHz subcarrier spacing</span>
simParameters.SSBurst.SSBTransmitted = [0 1 0 1]; <span class="comment">% Bitmap indicating blocks transmitted in the burst</span>
simParameters.SSBurst.SSBPeriodicity = 20;        <span class="comment">% SS burst set periodicity in ms (5, 10, 20, 40, 80, 160)</span>
</pre><p>Additional parameters can be set depending on the type of modulation waveform used.</p><p>For W-OFDM you can specify:</p><div><ul><li>The window roll-off factor</li><li>The windowing function samples. This parameter is optional and defaults to root raised cosine if unspecified</li></ul></div><p>For F-OFDM you can specify:</p><div><ul><li>The filter length</li><li>The tone offset</li></ul></div><p>For more information on how to parameterize the different waveforms see the help for <a href="matlab:help('h5gOFDMModulate')">h5gOFDMModulate</a> and [ <a href="#14">5</a> ].</p><pre class="codeinput"><span class="comment">% W-OFDM specific parameters</span>
simParameters.Alpha = 0.0125;

<span class="comment">% F-OFDM specific parameters</span>
simParameters.FilterLength = 513;
simParameters.ToneOffset = 2.5;
</pre><p>Calculate the 5G standard defined TBS, given the PDSCH configuration</p><pre class="codeinput"><span class="comment">% Create gNodeB configuration structure 'gnb' and PDSCH configuration</span>
<span class="comment">% structure 'pdsch'</span>
gnb = simParameters;
pdsch = simParameters.PDSCH;

<span class="comment">% Get PDSCH resourcing information</span>
[~,~,~,pdschIndicesInfo] = h5gPDSCHResources(gnb,pdsch);

Xoh_PDSCH = 0;     <span class="comment">% The Xoh-PDSCH overhead value is taken to be 0 here</span>
tbs = h5gPDSCHTBS(pdsch,pdschIndicesInfo.NREPerPRB-Xoh_PDSCH);

<span class="comment">% Create a vector of TBSs, one per group of 10 slots, since the HARQ</span>
<span class="comment">% processing in this example uses LTE oriented HARQ management code</span>
trBlkSizes = tbs*ones(1,10);
</pre><h2 id="6">Propagation Channel Model Configuration</h2><p>Create the channel model object. Both CDL and TDL channel models are supported [ <a href="#14">6</a> ].</p><pre class="codeinput">nTxAnts = simParameters.PDSCH.NTxAnts;
nRxAnts = simParameters.NRxAnts;

<span class="keyword">if</span> strcmpi(simParameters.ChannelType,<span class="string">'CDL'</span>)
    channel = nr5gCDLChannel; <span class="comment">% CDL channel object</span>

    <span class="comment">% Use CDL-C model (Urban macrocell model (R1-161736, R1-162960))</span>
    channel.DelayProfile = <span class="string">'CDL-C'</span>;
    channel.DelaySpread = 300e-9;

    <span class="comment">% Turn the overall number of transmit antennas into a specific antenna</span>
    <span class="comment">% panel array geometry</span>
    <span class="comment">%</span>
    <span class="comment">% Table of antenna panel array configurations</span>
    <span class="comment">% M:  no. of rows in each antenna panel</span>
    <span class="comment">% N:  no. of columns in each antenna panel</span>
    <span class="comment">% P:  no. of polarizations (1 or 2)</span>
    <span class="comment">% Mg: no. of rows in the array of panels</span>
    <span class="comment">% Ng: no. of columns in the array of panels</span>
    <span class="comment">% Row format: [M  N   P   Mg  Ng]</span>
    antarrays = <span class="keyword">...</span>
        [1   1   1   1   1;   <span class="comment">% 1 ants</span>
         1   1   2   1   1;   <span class="comment">% 2 ants</span>
         2   1   2   1   1;   <span class="comment">% 4 ants</span>
         2   2   2   1   1;   <span class="comment">% 8 ants</span>
         2   4   2   1   1;   <span class="comment">% 16 ants</span>
         4   4   2   1   1;   <span class="comment">% 32 ants</span>
         4   4   2   1   2;   <span class="comment">% 64 ants</span>
         4   8   2   1   2;   <span class="comment">% 128 ants</span>
         4   8   2   2   2;   <span class="comment">% 256 ants</span>
         8   8   2   2   2;   <span class="comment">% 512 ants</span>
         8  16   2   2   2];  <span class="comment">% 1024 ants</span>
     antselected = 1+fix(log2(nTxAnts));
     channel.TransmitAntennaArray.Size = antarrays(antselected,:);

    <span class="comment">% Setup the receive antenna geometry</span>
    <span class="keyword">if</span> nRxAnts == 1
        <span class="comment">% In the following settings, the number of rows in antenna array,</span>
        <span class="comment">% columns in antenna array, polarizations, row array panels and the</span>
        <span class="comment">% columns array panels are all 1</span>
        channel.ReceiveAntennaArray.Size = ones(1,5);
    <span class="keyword">else</span>
        <span class="comment">% In the following settings, the no. of rows in antenna array is</span>
        <span class="comment">% nRxAntennas/2, the no. of columns in antenna array is 1, the no.</span>
        <span class="comment">% of polarizations is 2, the no. of row array panels is 1 and the</span>
        <span class="comment">% no. of column array panels is 1. The values can be changed to</span>
        <span class="comment">% create alternative antenna setups</span>
        channel.ReceiveAntennaArray.Size = [fix(nRxAnts/2),1,2,1,1];
    <span class="keyword">end</span>

<span class="keyword">elseif</span> strcmpi(simParameters.ChannelType,<span class="string">'TDL'</span>)
    channel = nr5gTDLChannel; <span class="comment">% TDL channel object</span>
    <span class="comment">% Set the channel geometry</span>
    channel.DelayProfile = <span class="string">'TDL-C'</span>;
    channel.DelaySpread = 300e-9;
    channel.NumTransmitAntennas = nTxAnts;
    channel.NumReceiveAntennas = nRxAnts;
    channel.PathGainsOutputPort = true;  <span class="comment">% Provide the path gains as an output</span>
<span class="keyword">else</span>
    error(<span class="string">'ChannelType parameter field must be either CDL or TDL'</span>);
<span class="keyword">end</span>
</pre><p>The sampling rate for the channel model is set using the value returned from <a href="matlab:help('h5gOFDMInfo')">h5gOFDMInfo</a>.</p><pre class="codeinput">waveformInfo = h5gOFDMInfo(gnb);
channel.SampleRate = waveformInfo.SamplingRate;
</pre><p>Get the maximum number of delayed samples by a channel multipath component. This is calculated from the channel path with the largest delay and the implementation delay of the channel filter. This is required later to flush the channel filter to obtain the received signal.</p><pre class="codeinput">chInfo = info(channel);
maxChDelay = ceil(max(chInfo.PathDelays*channel.SampleRate)) + chInfo.ChannelFilterDelay;
</pre><h2 id="9">Reserve PDSCH Resources Corresponding to SS burst</h2><p>The figure below shows the signals and channels generated in the example.</p><p><img vspace="5" hspace="5" src="5GAddOnExampleWaveform.png" alt=""> </p><p>This section shows how to reserve resources for the transmission of the SS burst.</p><pre class="codeinput"><span class="comment">% Create SS burst waveform and information structure and display a plot</span>
<span class="comment">% showing the SS burst content (in the SS burst numerology)</span>
ssburst = simParameters.SSBurst;
ssburst.DisplayBurst = true;
[ssbWaveform,~,ssbInfo] = h5gSSBurst(gnb,ssburst);

<span class="comment">% Demodulate SS burst waveform using data numerology - note that depending</span>
<span class="comment">% on subcarrier spacings, the SS burst content may not be orthogonal with</span>
<span class="comment">% the data subcarriers</span>
ssbGrid = h5gOFDMDemodulate(gnb,ssbWaveform);

<span class="comment">% Map the occupied subcarriers and transmitted symbols of the SS burst</span>
<span class="comment">% (defined in the SS burst numerology) to PDSCH PRBs and symbols in the</span>
<span class="comment">% data numerology</span>
[mappedPRB,mappedSymbols] = mapNumerology(ssbInfo.OccupiedSubcarriers,ssbInfo.SymbolsTransmitted,ssbInfo.SubcarrierSpacing,gnb.SubcarrierSpacing);

<span class="comment">% Configure the PDSCH to reserve these resources so that the PDSCH</span>
<span class="comment">% transmission does not overlap the SS burst</span>
reservation.Symbols = mappedSymbols;
reservation.PRB = mappedPRB;
reservation.Period = simParameters.SSBurst.SSBPeriodicity * waveformInfo.SymbolsPerSubframe;
pdsch.Reserved(end+1) = reservation;

<span class="comment">% Create a plot showing the PDSCH, PDSCH DM-RS and SS burst resources</span>
plotPDSCHResources(gnb,pdsch,ssbGrid);
</pre><img vspace="5" hspace="5" src="NewRadio5GLinkExample_01.png" alt=""> <img vspace="5" hspace="5" src="NewRadio5GLinkExample_02.png" alt=""> <h2 id="10">Processing Loop</h2><p>To determine the throughput at each SNR point, the PDSCH data is analyzed per transmission instance using the following steps:</p><div><ul><li><i>Update current HARQ process.</i> The HARQ process either carries new transport data or a retransmission of previously sent transport data depending upon the acknowledgment (ACK) or negative acknowledgment (NACK). ACK or NACKs are not transmitted in this example, instead this is signaled using the CRC results. All this is handled by the HARQ scheduler, <a href="matlab:edit('hHARQScheduling.m')">hHARQScheduling.m</a>. The PDSCH data is updated based on the HARQ state.</li></ul></div><div><ul><li><i>Resource grid generation.</i> The data generated by the HARQ process is channel coded and modulated on the PDSCH by <a href="matlab:doc('h5gDLSCH')">h5gDLSCH</a> and <a href="matlab:doc('ltePDSCH')">ltePDSCH</a>. The precoding operation is also performed in this step.</li></ul></div><div><ul><li><i>Waveform generation.</i> The generated grid is then OFDM modulated.</li></ul></div><div><ul><li><i>Noisy channel modeling.</i> The waveform is passed through a CDL or TDL fading channel. AWGN is added.</li></ul></div><div><ul><li><i>Perform synchronization and OFDM demodulation.</i> Information returned by the channel is used for perfect synchronization. The synchronized signal is then OFDM demodulated.</li></ul></div><div><ul><li><i>Perform perfect channel estimation.</i> Perfect channel estimation is used.</li></ul></div><div><ul><li><i>Precoding matrix calculation.</i> The precoding matrix W for the next transmission is calculated using singular value decomposition (SVD). A single matrix is obtained for the full allocation by averaging the channel conditions. Therefore, for a channel with frequency selectivitiy, W could be less accurate for larger allocated bandwidths.</li></ul></div><div><ul><li><i>Decode the PDSCH.</i> The recovered PDSCH symbols for all transmit and receive antenna pairs, along with a noise estimate, are demodulated and descrambled by <a href="matlab:doc('h5gPDSCHDecode')">h5gPDSCHDecode</a> to obtain an estimate of the received codewords. Note that this function is a modified version of <a href="matlab:doc('ltePDSCHDecode')">ltePDSCHDecode</a> which creates an LLR output which is compatible with the LDPC decoder used in the 5G DL-SCH decoding.</li></ul></div><div><ul><li><i>Decode the Downlink Shared Channel (DL-SCH) and store the block CRC error for a HARQ process.</i> The vector of decoded soft bits is passed to <a href="matlab:doc('h5gDLSCHDecode')">h5gDLSCHDecode</a> which decodes the codeword and returns the block CRC error used to determine the throughput of the system. The contents of the updated soft buffer, <tt>harqProc(harqIdx).decState</tt>, are available at the output of this function to be used when decoding the next retransmission, if required.</li></ul></div><pre class="codeinput"><span class="comment">% Initialize variables used in the simulation and analysis</span>
<span class="comment">% Array to store the maximum throughput for all SNR points</span>
maxThroughput = zeros(length(simParameters.SNRIn),1);
<span class="comment">% Array to store the simulation throughput for all SNR points</span>
simThroughput = zeros(length(simParameters.SNRIn),1);

<span class="comment">% Specify additional required fields for PDSCH</span>
pdsch.TxScheme = <span class="string">'Port7-14'</span>;
pdsch.RNTI = 1;

<span class="comment">% Set up Redundancy Version (RV) sequence, number of HARQ processes and</span>
<span class="comment">% the sequence in which the HARQ processes are used</span>
<span class="keyword">if</span> pdsch.EnableHARQ
    <span class="comment">% In the final report of RAN WG1 meeting #91 (R1-1719301), it was</span>
    <span class="comment">% observed in R1-1717405 that if performance is the priority, [0 2 3 1]</span>
    <span class="comment">% should be used. If self-decodability is the priority, it should be</span>
    <span class="comment">% taken into account that the upper limit of the code rate at which</span>
    <span class="comment">% each RV is self-decodable is in the following order: 0&gt;3&gt;&gt;2&gt;1</span>
    rvSeq = [0 2 3 1];
<span class="keyword">else</span>
    <span class="comment">% HARQ disabled - single transmission with RV=0, no retransmissions</span>
    rvSeq = 0;
<span class="keyword">end</span>
pdsch.NHARQProcesses = 8;
harqSequence = 1:pdsch.NHARQProcesses;

<span class="keyword">for</span> snrIdx = 1:numel(simParameters.SNRIn)

    <span class="comment">% Set the random number generator settings to default values</span>
    rng(<span class="string">'default'</span>);

    SNRdB = simParameters.SNRIn(snrIdx);
    fprintf(<span class="string">'\nSimulating transmission scheme 1 (%dx%d) and %s (SCS=%dkHz) with %s channel at %gdB SNR for %d 10ms frame(s)\n'</span>,<span class="keyword">...</span>
        nTxAnts,nRxAnts,gnb.WaveformType,gnb.SubcarrierSpacing, <span class="keyword">...</span>
        simParameters.ChannelType,SNRdB,simParameters.NFrames);

    <span class="comment">% Initialize variables used in the simulation and analysis</span>
    blkCRC = [];            <span class="comment">% Block CRC for all active PDSCH transmissions</span>
    bitTput = [];           <span class="comment">% Number of successfully received bits per transmission</span>
    txedTrBlkSizes = [];    <span class="comment">% Number of transmitted info bits per transmission</span>

    <span class="comment">% Initialize the state of all HARQ processes</span>
    pdsch.TrBlkSizes = trBlkSizes;
    gnb.PDSCH = pdsch;
    harqProcesses = hNewHARQProcess(gnb);

    <span class="comment">% Reset the channel so that each SNR point will experience the same</span>
    <span class="comment">% channel realization</span>
    reset(channel);

    <span class="comment">% Total number of OFDM symbols in the simulation period</span>
    NSymbols = simParameters.NFrames * 10 * waveformInfo.SymbolsPerSubframe;

    <span class="comment">% OFDM symbol number associated with start of each PDSCH transmission</span>
    gnb.NSymbol = 0;

    <span class="comment">% Running counter of the number of PDSCH transmission instances</span>
    <span class="comment">% The simulation will use this counter as the slot number for each</span>
    <span class="comment">% PDSCH</span>
    npdsch = 0;

    <span class="comment">% Index to the start of the current set of SS burst samples to be</span>
    <span class="comment">% transmitted. Also record which SS blocks in the burst are configured</span>
    <span class="comment">% for transmission, a bitmap of all zeros will be used to create a</span>
    <span class="comment">% waveform with the correct SSB periodicity</span>
    ssbSampleIndex = 1;
    ssbTransmitted = ssburst.SSBTransmitted;
    ssburst.DisplayBurst = false;

    <span class="comment">% Obtain a precoding matrix to be used in the transmission of the first</span>
    <span class="comment">% transport block</span>
    estChannelGrid = getInitialChannelEstimate(gnb,pdsch,channel);
    wtx = getPrecodingMatrix(pdsch,estChannelGrid);

    <span class="keyword">while</span>  gnb.NSymbol &lt; NSymbols

        <span class="comment">% Set the current slot number</span>
        pdsch.NSlot = npdsch;

        <span class="comment">% Generate a new SS burst when necessary</span>
        <span class="keyword">if</span> (ssbSampleIndex==1)
            nsf = gnb.NSymbol / waveformInfo.SymbolsPerSubframe;
            ssburst.SSBTransmitted = ssbTransmitted * (mod(nsf,simParameters.SSBurst.SSBPeriodicity)==0);
            ssburst.NHalfFrame = mod(nsf / 5,2);
            [ssbWaveform,~,ssbInfo] = h5gSSBurst(gnb,ssburst);
        <span class="keyword">end</span>

        <span class="comment">% Get HARQ process index for the current PDSCH from HARQ index table</span>
        harqProcIdx = harqSequence(mod(npdsch,length(harqSequence))+1);

        <span class="comment">% Update current HARQ process information</span>
        harqProcesses(harqProcIdx) = hHARQScheduling(harqProcesses(harqProcIdx),npdsch,rvSeq);

        <span class="comment">% Extract the current PDSCH transport block size</span>
        trBlk = trBlkSizes(:, mod(npdsch,size(trBlkSizes,2))+1).';

        <span class="comment">% Update the PDSCH transmission config from the HARQ process state</span>
        pdsch = harqProcesses(harqProcIdx).txConfig;
        trdata = harqProcesses(harqProcIdx).data;

        <span class="comment">% PDSCH resource element indices and PDSCH DM-RS</span>
        [pdschIndices,dmrsIndices,dmrsSymbols,pdschIndicesInfo] = h5gPDSCHResources(gnb,pdsch);

        <span class="comment">% Perform DL-SCH transport channel coding</span>
        codedTrBlock = h5gDLSCH(gnb,pdsch,pdschIndicesInfo.G,trdata);

        <span class="comment">% Use LTE PDSCH in beamforming mode to create the transmission</span>
        <span class="comment">% symbols, which requires some additional function-specific</span>
        <span class="comment">% parameters to be set</span>
        gnb.CellRefP = 1;
        pdsch.W = wtx;
        <span class="comment">% Update effective subframe number to be used to generate the LTE</span>
        <span class="comment">% PDSCH scrambling etc. For SCS &gt; 15kHz (15kHz * 2^n) this will</span>
        <span class="comment">% compress the scrambling frame structure into periods of 1/(2^n)</span>
        <span class="comment">% milliseconds. The true 1ms subframe number will be:</span>
        <span class="comment">% fix(gnb.NSymbol/waveformInfo.symbolsPerSubframe)</span>
        gnb.NSubframe = npdsch;
        pdschSymbols = ltePDSCH(gnb,pdsch,codedTrBlock);

        <span class="comment">% PDSCH mapping in grid associated with PDSCH transmission period</span>
        pdschGrid = zeros(waveformInfo.NSubcarriers,waveformInfo.SymbolsPerSlot,nTxAnts);
        [~,pdschAntIndices] = lteExtractResources(pdschIndices,pdschGrid);
        pdschGrid(pdschAntIndices) = pdschSymbols;

        <span class="comment">% PDSCH DM-RS precoding and mapping</span>
        <span class="keyword">for</span> p = 1:size(dmrsSymbols,2)
            [~,dmrsAntIndices] = lteExtractResources(dmrsIndices(:,p),pdschGrid);
            pdschGrid(dmrsAntIndices) = pdschGrid(dmrsAntIndices) + dmrsSymbols(:,p) * wtx(p,:);
        <span class="keyword">end</span>

        <span class="comment">% OFDM modulation of associated resource elements</span>
        txWaveform = h5gOFDMModulate(gnb, pdschGrid);

        <span class="comment">% Add the appropriate portion of SS burst waveform to the</span>
        <span class="comment">% transmitted waveform</span>
        Nt = size(txWaveform,1);
        txWaveform = txWaveform + ssbWaveform(ssbSampleIndex + (0:Nt-1),:);
        ssbSampleIndex = mod(ssbSampleIndex + Nt,size(ssbWaveform,1));

        <span class="comment">% Pass data through channel model. Append zeros at the end of the</span>
        <span class="comment">% transmitted waveform to flush channel content. These zeros take</span>
        <span class="comment">% into account any delay introduced in the channel. This is a mix</span>
        <span class="comment">% of multipath delay and implementation delay. This value may</span>
        <span class="comment">% change depending on the sampling rate, delay profile and delay</span>
        <span class="comment">% spread</span>
        txWaveform = [txWaveform; zeros(maxChDelay, size(txWaveform,2))]; <span class="comment">%#ok&lt;AGROW&gt;</span>
        [rxWaveform,pathGains] = channel(txWaveform);

        <span class="comment">% Calculate linear noise gain</span>
        SNR = 10^(SNRdB/20);

        <span class="comment">% Normalize noise power to take account of sampling rate, which is</span>
        <span class="comment">% a function of the IFFT size used in OFDM modulation</span>
        N0 = 1/(sqrt(2.0*double(waveformInfo.Nfft))*SNR);

        <span class="comment">% Create additive white Gaussian noise</span>
        noise = N0*complex(randn(size(rxWaveform)),randn(size(rxWaveform)));

        <span class="comment">% Add AWGN to the received time domain waveform</span>
        rxWaveform = rxWaveform + noise;

        <span class="comment">% Perfect synchronization. Use information provided by the channel</span>
        <span class="comment">% to find the strongest multipath component</span>
        [offset,mag] = h5gPerfectTimingOffset(pathGains,chInfo,waveformInfo.SamplingRate);
        rxWaveform = rxWaveform(1+offset:end, :);

        <span class="comment">% Perform OFDM demodulation on the received data to recreate the</span>
        <span class="comment">% resource grid</span>
        rxGrid = h5gOFDMDemodulate(gnb, rxWaveform);

        <span class="comment">% Perfect channel estimation, use the value of the path gains</span>
        <span class="comment">% provided by the channel</span>
        <span class="comment">% Get estimates for the transmission period of LTE PDSCH instance</span>
        <span class="comment">% (in terms of symbols, this is equivalent to an LTE subframe)</span>
        estChannelGrid = h5gPerfectChannelEstimate(gnb,channel,pathGains,offset);

        <span class="comment">% Noise estimation directly from the noise realization</span>
        noiseGrid = h5gOFDMDemodulate(gnb, noise(1+offset:end ,:));
        noiseEst = var(noiseGrid(:));

        wtx = getPrecodingMatrix(pdsch,estChannelGrid);

        <span class="comment">% Apply precoding to Hest</span>
        <span class="comment">% Linearize 4D matrix and reshape after multiplication</span>
        K = size(estChannelGrid,1);
        Hest = reshape(estChannelGrid,K*waveformInfo.SymbolsPerSlot*nRxAnts,nTxAnts);
        Hest = Hest*pdsch.W.';
        Hest = reshape(Hest,K,waveformInfo.SymbolsPerSlot,nRxAnts,pdsch.NLayers);

        <span class="comment">% Get PDSCH resource elements from the received grid</span>
        [pdschRx,pdschHest] = lteExtractResources(pdschIndices,rxGrid,Hest);

        <span class="comment">% Decode LTE PDSCH physical channel</span>
        <span class="comment">% This uses a modified version of ltePDSCHDecode which creates</span>
        <span class="comment">% an LLR output which is compatible with the LDPC decoder used in</span>
        <span class="comment">% the 5G DL-SCH decoding</span>
        [dlschBits,rxSymbols] = h5gPDSCHDecode(gnb,pdsch,pdschRx,pdschHest,noiseEst);

        <span class="comment">% Decode the DL-SCH transport channel</span>
        [decbits,harqProcesses(harqProcIdx).blkerr,harqProcesses(harqProcIdx).decState] = <span class="keyword">...</span>
            h5gDLSCHDecode(gnb,pdsch,trBlk,dlschBits,harqProcesses(harqProcIdx).decState);

        <span class="comment">% Store values to calculate throughput (only for active PDSCH instances)</span>
        <span class="keyword">if</span>(any(trBlk) ~= 0)
            blkCRC = [blkCRC harqProcesses(harqProcIdx).blkerr];                <span class="comment">%#ok&lt;AGROW&gt;</span>
            bitTput = [bitTput trBlk.*(1-harqProcesses(harqProcIdx).blkerr)];   <span class="comment">%#ok&lt;AGROW&gt;</span>
            txedTrBlkSizes = [txedTrBlkSizes trBlk];                            <span class="comment">%#ok&lt;AGROW&gt;</span>
        <span class="keyword">end</span>

        <span class="comment">% Update starting symbol number of next PDSCH transmission</span>
        gnb.NSymbol = gnb.NSymbol + size(pdschGrid,2);
        <span class="comment">% Update count of overall number of PDSCH transmissions</span>
        npdsch = npdsch + 1;

        <span class="comment">% Display transport block error information per codeword managed by current HARQ process</span>
        fprintf(<span class="string">'\n(%3.2f%%) HARQ Proc %d: '</span>, 100*gnb.NSymbol/NSymbols,harqProcIdx);
        estrings = {<span class="string">'passed'</span>,<span class="string">'failed'</span>};
        rvi = harqProcesses(harqProcIdx).txConfig.RVIdx;
        <span class="keyword">for</span> cw=1:length(rvi)
            cwrvi = rvi(cw);
            <span class="comment">% Create a report on the RV state given position in RV sequence and decoding error</span>
            <span class="keyword">if</span> cwrvi == 1
                ts = sprintf(<span class="string">'Initial transmission (RV=%d)'</span>,rvSeq(cw,cwrvi));
            <span class="keyword">else</span>
                ts = sprintf(<span class="string">'Retransmission #%d (RV=%d)'</span>,cwrvi-1,rvSeq(cw,cwrvi));
            <span class="keyword">end</span>
            fprintf(<span class="string">'CW%d - %s %s. '</span>,cw-1,ts,estrings{1+harqProcesses(harqProcIdx).blkerr(cw)});
        <span class="keyword">end</span>

     <span class="keyword">end</span>

    <span class="comment">% Calculate maximum and simulated throughput</span>
    maxThroughput(snrIdx) = sum(txedTrBlkSizes); <span class="comment">% Max possible throughput</span>
    simThroughput(snrIdx) = sum(bitTput,2);      <span class="comment">% Simulated throughput</span>

    <span class="comment">% Display the results dynamically in the command window</span>
    fprintf([[<span class="string">'\n\nThroughput(Mbps) for '</span>, num2str(simParameters.NFrames) <span class="string">' frame(s) '</span>],<span class="keyword">...</span>
        <span class="string">'= %.4f\n'</span>], 1e-6*simThroughput(snrIdx)/(simParameters.NFrames*10e-3*(2/waveformInfo.SlotsPerSubframe)));
    fprintf([<span class="string">'Throughput(%%) for '</span>, num2str(simParameters.NFrames) <span class="string">' frame(s) = %.4f\n'</span>],<span class="keyword">...</span>
        simThroughput(snrIdx)*100/maxThroughput(snrIdx));

<span class="keyword">end</span>
</pre><pre class="codeoutput">
Simulating transmission scheme 1 (8x2) and CP-OFDM (SCS=15kHz) with CDL channel at -5dB SNR for 2 10ms frame(s)

(5.00%) HARQ Proc 1: CW0 - Initial transmission (RV=0) failed. 
(10.00%) HARQ Proc 2: CW0 - Initial transmission (RV=0) failed. 
(15.00%) HARQ Proc 3: CW0 - Initial transmission (RV=0) failed. 
(20.00%) HARQ Proc 4: CW0 - Initial transmission (RV=0) failed. 
(25.00%) HARQ Proc 5: CW0 - Initial transmission (RV=0) failed. 
(30.00%) HARQ Proc 6: CW0 - Initial transmission (RV=0) failed. 
(35.00%) HARQ Proc 7: CW0 - Initial transmission (RV=0) failed. 
(40.00%) HARQ Proc 8: CW0 - Initial transmission (RV=0) failed. 
(45.00%) HARQ Proc 1: CW0 - Retransmission #1 (RV=2) failed. 
(50.00%) HARQ Proc 2: CW0 - Retransmission #1 (RV=2) failed. 
(55.00%) HARQ Proc 3: CW0 - Retransmission #1 (RV=2) failed. 
(60.00%) HARQ Proc 4: CW0 - Retransmission #1 (RV=2) failed. 
(65.00%) HARQ Proc 5: CW0 - Retransmission #1 (RV=2) failed. 
(70.00%) HARQ Proc 6: CW0 - Retransmission #1 (RV=2) failed. 
(75.00%) HARQ Proc 7: CW0 - Retransmission #1 (RV=2) failed. 
(80.00%) HARQ Proc 8: CW0 - Retransmission #1 (RV=2) failed. 
(85.00%) HARQ Proc 1: CW0 - Retransmission #2 (RV=3) failed. 
(90.00%) HARQ Proc 2: CW0 - Retransmission #2 (RV=3) failed. 
(95.00%) HARQ Proc 3: CW0 - Retransmission #2 (RV=3) failed. 
(100.00%) HARQ Proc 4: CW0 - Retransmission #2 (RV=3) failed. 

Throughput(Mbps) for 2 frame(s) = 0.0000
Throughput(%) for 2 frame(s) = 0.0000

Simulating transmission scheme 1 (8x2) and CP-OFDM (SCS=15kHz) with CDL channel at 0dB SNR for 2 10ms frame(s)

(5.00%) HARQ Proc 1: CW0 - Initial transmission (RV=0) failed. 
(10.00%) HARQ Proc 2: CW0 - Initial transmission (RV=0) failed. 
(15.00%) HARQ Proc 3: CW0 - Initial transmission (RV=0) failed. 
(20.00%) HARQ Proc 4: CW0 - Initial transmission (RV=0) failed. 
(25.00%) HARQ Proc 5: CW0 - Initial transmission (RV=0) failed. 
(30.00%) HARQ Proc 6: CW0 - Initial transmission (RV=0) failed. 
(35.00%) HARQ Proc 7: CW0 - Initial transmission (RV=0) failed. 
(40.00%) HARQ Proc 8: CW0 - Initial transmission (RV=0) failed. 
(45.00%) HARQ Proc 1: CW0 - Retransmission #1 (RV=2) passed. 
(50.00%) HARQ Proc 2: CW0 - Retransmission #1 (RV=2) passed. 
(55.00%) HARQ Proc 3: CW0 - Retransmission #1 (RV=2) passed. 
(60.00%) HARQ Proc 4: CW0 - Retransmission #1 (RV=2) passed. 
(65.00%) HARQ Proc 5: CW0 - Retransmission #1 (RV=2) passed. 
(70.00%) HARQ Proc 6: CW0 - Retransmission #1 (RV=2) passed. 
(75.00%) HARQ Proc 7: CW0 - Retransmission #1 (RV=2) passed. 
(80.00%) HARQ Proc 8: CW0 - Retransmission #1 (RV=2) passed. 
(85.00%) HARQ Proc 1: CW0 - Initial transmission (RV=0) failed. 
(90.00%) HARQ Proc 2: CW0 - Initial transmission (RV=0) failed. 
(95.00%) HARQ Proc 3: CW0 - Initial transmission (RV=0) failed. 
(100.00%) HARQ Proc 4: CW0 - Initial transmission (RV=0) failed. 

Throughput(Mbps) for 2 frame(s) = 0.9984
Throughput(%) for 2 frame(s) = 40.0000

Simulating transmission scheme 1 (8x2) and CP-OFDM (SCS=15kHz) with CDL channel at 5dB SNR for 2 10ms frame(s)

(5.00%) HARQ Proc 1: CW0 - Initial transmission (RV=0) passed. 
(10.00%) HARQ Proc 2: CW0 - Initial transmission (RV=0) passed. 
(15.00%) HARQ Proc 3: CW0 - Initial transmission (RV=0) passed. 
(20.00%) HARQ Proc 4: CW0 - Initial transmission (RV=0) passed. 
(25.00%) HARQ Proc 5: CW0 - Initial transmission (RV=0) passed. 
(30.00%) HARQ Proc 6: CW0 - Initial transmission (RV=0) passed. 
(35.00%) HARQ Proc 7: CW0 - Initial transmission (RV=0) passed. 
(40.00%) HARQ Proc 8: CW0 - Initial transmission (RV=0) passed. 
(45.00%) HARQ Proc 1: CW0 - Initial transmission (RV=0) passed. 
(50.00%) HARQ Proc 2: CW0 - Initial transmission (RV=0) passed. 
(55.00%) HARQ Proc 3: CW0 - Initial transmission (RV=0) passed. 
(60.00%) HARQ Proc 4: CW0 - Initial transmission (RV=0) passed. 
(65.00%) HARQ Proc 5: CW0 - Initial transmission (RV=0) passed. 
(70.00%) HARQ Proc 6: CW0 - Initial transmission (RV=0) passed. 
(75.00%) HARQ Proc 7: CW0 - Initial transmission (RV=0) passed. 
(80.00%) HARQ Proc 8: CW0 - Initial transmission (RV=0) passed. 
(85.00%) HARQ Proc 1: CW0 - Initial transmission (RV=0) passed. 
(90.00%) HARQ Proc 2: CW0 - Initial transmission (RV=0) passed. 
(95.00%) HARQ Proc 3: CW0 - Initial transmission (RV=0) passed. 
(100.00%) HARQ Proc 4: CW0 - Initial transmission (RV=0) passed. 

Throughput(Mbps) for 2 frame(s) = 2.4960
Throughput(%) for 2 frame(s) = 100.0000
</pre><h2 id="11">Results</h2><p>Display the measured throughput. This is calculated as the percentage of the maximum possible throughput of the link given the available resources for data transmission.</p><pre class="codeinput">figure;
plot(simParameters.SNRIn,simThroughput*100./maxThroughput,<span class="string">'o-.'</span>)
xlabel(<span class="string">'SNR (dB)'</span>); ylabel(<span class="string">'Throughput (%)'</span>); grid <span class="string">on</span>;
title(sprintf(<span class="string">'%s / (%dx%d) / %s / NDLRB=%d / SCS=%dkHz'</span>,<span class="keyword">...</span>
               pdsch.CodingType,nTxAnts,nRxAnts,gnb.WaveformType, <span class="keyword">...</span>
               gnb.NDLRB,gnb.SubcarrierSpacing));

<span class="comment">% Bundle key parameters and results into a combined structure for recording</span>
simResults.simParameters = simParameters;
simResults.simThroughput = simThroughput;
</pre><img vspace="5" hspace="5" src="NewRadio5GLinkExample_03.png" alt=""> <p>The figure below shows the throughput obtained when simulating 1000 frames.</p><p><img vspace="5" hspace="5" src="nr5gLongRunThroughput.png" alt=""> </p><h2 id="13">Appendix</h2><p>This example uses the following helper functions:</p><div><ul><li><a href="matlab:edit('hNewHARQProcess.m')">hNewHARQProcess.m</a></li><li><a href="matlab:edit('hHARQScheduling.m')">hHARQScheduling.m</a></li><li><a href="matlab:edit('h5gOFDMModulate.m')">h5gOFDMModulate.m</a></li><li><a href="matlab:edit('h5gOFDMDemodulate.m')">h5gOFDMDemodulate.m</a></li><li><a href="matlab:edit('h5gOFDMInfo.m')">h5gOFDMInfo.m</a></li><li><a href="matlab:edit('h5gDLSCHInfo.m')">h5gDLSCHInfo.m</a></li><li><a href="matlab:edit('h5gPDSCHTBS.m')">h5gPDSCHTBS.m</a></li><li><a href="matlab:edit('h5gPDSCHResources.m')">h5gPDSCHResources.m</a></li><li><a href="matlab:edit('h5gDLSCH.m')">h5gDLSCH.m</a></li><li><a href="matlab:edit('h5gDLSCHDecode.m')">h5gDLSCHDecode.m</a></li><li><a href="matlab:edit('h5gPDSCHDecode.m')">h5gPDSCHDecode.m</a></li><li><a href="matlab:edit('h5gCodeBlockSegment.m')">h5gCodeBlockSegment.m</a></li><li><a href="matlab:edit('h5gCodeBlockDesegment.m')">h5gCodeBlockDesegment.m</a></li><li><a href="matlab:edit('h5gLDPCEncode.m')">h5gLDPCEncode.m</a></li><li><a href="matlab:edit('h5gLDPCDecode.m')">h5gLDPCDecode.m</a></li><li><a href="matlab:edit('h5gRateMatchLDPC.m')">h5gRateMatchLDPC.m</a></li><li><a href="matlab:edit('h5gRateRecoverLDPC.m')">h5gRateRecoverLDPC.m</a></li><li><a href="matlab:edit('h5gLDPCParityCheckMatrix.m')">h5gLDPCParityCheckMatrix.m</a></li><li><a href="matlab:edit('h5gSSBurst.m')">h5gSSBurst.m</a></li><li><a href="matlab:edit('h5gPerfectTimingOffset.m')">h5gPerfectTimingOffset.m</a></li><li><a href="matlab:edit('h5gPerfectChannelEstimate.m')">h5gPerfectChannelEstimate.m</a></li></ul></div><h2 id="14">Selected Bibliography</h2><div><ol><li>3GPP TS 38.211 V15.0 "NR; Physical channels and modulation"</li><li>3GPP TS 38.212 V15.0 "NR; Multiplexing and channel coding"</li><li>3GPP TS 38.213 V15.0 "NR; Physical layer procedures for control"</li><li>3GPP TS 38.214 V15.0 "NR; Physical layer procedures for data"</li><li>R1-166999, "Detailed configuration of F-OFDM and W-OFDM for LLS evaluation", Spreadtrum Communications, 3GPP RAN WG1 #86, August 2016</li><li>3GPP TR 38.901 V14.3 "Study on channel model for frequencies from 0.5 to 100 GHz"</li></ol></div><pre class="codeinput"><span class="keyword">function</span> estChannelGrid = getInitialChannelEstimate(gnb,pdsch,channel)

    ofdmInfo = h5gOFDMInfo(gnb);
    sr =       ofdmInfo.SamplingRate;

    chInfo = info(channel);
    maxChDelay = ceil(max(chInfo.PathDelays*channel.SampleRate)) + chInfo.ChannelFilterDelay;

    <span class="comment">% Temporary waveform (only needed for the sizes)</span>
    tmpWaveform = zeros((ofdmInfo.SamplesPerSubframe/ofdmInfo.SlotsPerSubframe)+maxChDelay,pdsch.NTxAnts);

    <span class="comment">% Filter through channel</span>
    [~,pathGains] = channel(tmpWaveform);

    <span class="comment">% Perfect timing synch</span>
    offset = h5gPerfectTimingOffset(pathGains,chInfo,sr);

    <span class="comment">% Perfect channel estimate</span>
    estChannelGrid = h5gPerfectChannelEstimate(gnb,channel,pathGains,offset);

<span class="keyword">end</span>

<span class="keyword">function</span> wtx = getPrecodingMatrix(pdsch,hestGrid)

    <span class="comment">% Allocated subcarrier indices</span>
    allocSc = (1:12)' + 12*pdsch.PRBSet(:).';
    allocSc = allocSc(:);

    <span class="comment">% Average channel estimate</span>
    [~,~,R,P] = size(hestGrid);
    estAllocGrid = hestGrid(allocSc,:,:,:);
    Hest = permute(mean(reshape(estAllocGrid,[],R,P)),[2 3 1]);

    <span class="comment">% SVD decomposition</span>
    [~,~,V] = svd(Hest);
    wtx = V(:,1:pdsch.NLayers).';

<span class="keyword">end</span>

<span class="keyword">function</span> [mappedPRB,mappedSymbols] = mapNumerology(subcarriers,symbols,fs,ft)

    mappedPRB = unique(fix(subcarriers*fs/(ft*12)),<span class="string">'stable'</span>);

    <span class="keyword">if</span> (ft &lt; fs)
        <span class="comment">% If ft/fs &lt; 1, reduction</span>
        mappedSymbols = unique(fix(symbols*ft/fs),<span class="string">'stable'</span>);
    <span class="keyword">else</span>
        <span class="comment">% Else, repetition by ft/fs</span>
        mappedSymbols = reshape((0:(ft/fs-1))' + symbols(:)'*ft/fs,1,[]);
    <span class="keyword">end</span>

<span class="keyword">end</span>

<span class="keyword">function</span> plotPDSCHResources(gnb,pdsch,ssbGrid)

    <span class="comment">% Create an empty resource grid spanning one slot</span>
    waveformInfo = h5gOFDMInfo(gnb);
    grid = zeros(waveformInfo.NSubcarriers,waveformInfo.SymbolsPerSlot,pdsch.NLayers);

    <span class="comment">% Trim the SS burst grid to contain the same number of OFDM symbols</span>
    ssbGrid= ssbGrid(:,1:size(grid,2));

    <span class="comment">% Create PDSCH and PDSCH DM-RS indices</span>
    [pdschIndices,pdschDmrsIndices] = h5gPDSCHResources(gnb,pdsch);

    <span class="comment">% Mark PDSCH and PDSCH DM-RS positions in the grid</span>
    grid(pdschIndices) = 2;
    grid(pdschDmrsIndices) = 3;

    <span class="comment">% Mark SS burst positions in the grid</span>
    grid(abs(ssbGrid)&gt;=0.5) = grid(abs(ssbGrid)&gt;=0.5) + 1;
    grid(abs(ssbGrid)&lt;0.5 &amp; abs(ssbGrid)&gt;=0.1) = grid(abs(ssbGrid)&lt;0.5 &amp; abs(ssbGrid)&gt;=0.1) + 0.3;
    grid(abs(ssbGrid)&lt;0.1 &amp; abs(ssbGrid)&gt;0.03) = grid(abs(ssbGrid)&lt;0.1 &amp; abs(ssbGrid)&gt;0.03) + 0.1;

    <span class="comment">% Plot the grid</span>
    figure;
    imagesc(abs(grid(:,:,1)));
    axis <span class="string">xy</span>;

    <span class="comment">% Create a legend for the different channels / signals, this is</span>
    <span class="comment">% achieved by drawing off-plot patches with the appropriate colors</span>
    <span class="comment">% then adding a legend</span>
    hold <span class="string">on</span>;
    patch([-2 -3 -3 -2],[-2 -2 -3 -3],1);
    patch([-2 -3 -3 -2],[-2 -2 -3 -3],2);
    patch([-2 -3 -3 -2],[-2 -2 -3 -3],3);
    legend(<span class="string">'SS burst'</span>,<span class="string">'PDSCH'</span>,<span class="string">'PDSCH DM-RS'</span>);

    <span class="comment">% Add axis labels and title</span>
    ylabel(<span class="string">'Subcarriers'</span>);
    xlabel(<span class="string">'OFDM symbols'</span>);
    title(sprintf(<span class="string">'PDSCH / DM-RS / SS burst, SCS=%dkHz, NDLRB=%d, Port=%d'</span>,gnb.SubcarrierSpacing,gnb.NDLRB,1000 + pdsch.PortSet(1)));
    drawnow;

<span class="keyword">end</span>
</pre><p class="footer">Copyright 2017-2018 The MathWorks, Inc.<br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2018a</a><br><br>
		  MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.
      </p></div><!--
##### SOURCE BEGIN #####
%% 3GPP 5G NR PDSCH Throughput Simulation
% This example measures the PDSCH throughput of a 5G link, as defined by
% the 3GPP NR standard. The example supports the 5G NR DL-SCH, PDSCH
% precoding, and 5G subcarrier spacings and bandwidths. The transmitter
% model includes 5G PDSCH DM-RS and SS burst. Both CDL and TDL propagation
% channels are supported.
% 
% Copyright 2017-2018 The MathWorks, Inc.

%% Introduction
% This example measures the PDSCH throughput of a 5G link, as defined by
% the 3GPP NR standard V15.0 [ <#14 1> ], [ <#14 2> ], [ <#14 3> ], 
% [ <#14 4> ].
% 
% The following 5G NR features are implemented:
%
% * 5G DL-SCH transport channel coding 
% * 5G PDSCH DM-RS generation
% * SS burst generation (PSS/SSS/PBCH/PBCH DM-RS)
% * NR subcarrier spacing and frame numerologies (2^n * 15kHz) for normal
% and extended cyclic prefix
% * Support for 5G bandwidths
% * 5G CP-OFDM, with the option of W-OFDM (WOLA-OFDM) and F-OFDM (Filtered
% OFDM)
% * TDL and CDL propagation channel models
% 
% The main features of the simulation are:
%
% * DL-SCH can be switched between 5G NR (LDPC) and LTE (turbo)
% * PDSCH non-codebook based precoding using SVD
% * Slot wise and non slot wise PDSCH and DM-RS mapping
% * SS burst generation (cases A-E, SS/PBCH block bitmap control)
% * NR subcarrier spacings and frame numerologies
% * CP-OFDM, F-OFDM and WOLA-OFDM waveform selection
% * TDL or CDL channel selection
% * Perfect synchronization and channel estimation
%
% The figure below shows the processing chain implemented. For clarity, the
% DM-RS and SS burst generation have been omitted. 
%
% <<5GAddOnExampleProcessingChain.png>>
%
% Note that perfect synchronization and perfect channel knowledge are
% assumed, i.e. SS/PBCH block and PDSCH DM-RS signals are not used at the
% receiver. In this example, the PDSCH implementation uses the LTE PDSCH
% configured for non-codebook based precoding and LTE PDSCH scrambling. A
% single precoding matrix for the whole PDSCH allocation is determined
% using SVD by averaging the channel estimate across all allocated PDSCH
% PRBs. Therefore for large PDSCH allocations i.e. occupying a wide
% bandwidth, the single precoding matrix may not be well matched to the
% channel across all frequencies, resulting in performance degradation.
% There is no beamforming on the SS/PBCH blocks in the SS burst.

%% Simulation Length and SNR Points
% Set the length of the simulation in terms of the number of 10ms frames.
% Set the SNR points to simulate.

simParameters = [];             % Clear simParameters variable
simParameters.NFrames = 2;      % Number of 10ms frames
simParameters.SNRIn = [-5 0 5]; % SNR range

%% gNodeB and PDSCH Configuration
% Set the key parameters of the simulation. These include:
%
% * The bandwidth in resource blocks (12 subcarriers per resource block).
% * Subcarrier spacing: 15, 30, 60, 120, 240, 480 (kHz)
% * Waveform: 'CP-OFDM', 'F-OFDM' or 'W-OFDM'
% * DC subcarrier flag
%
% A substructure containing the DL-SCH and PDSCH parameters is also
% specified. This includes:
%
% * Target code rate
% * Transport channel coding: 'LDPC', 'Turbo'
% * Allocated resource blocks (PRBSet)
% * Modulation scheme: 'QPSK', '16QAM', '64QAM', '256QAM'
% * Number of layers
% * Number of transmit antennas
% * PDSCH mapping type
% * DM-RS configuration parameters
%
% Other simulation wide parameters are:
%
% * Propagation channel model: 'TDL' or 'CDL'
% * Number of receive antennas
% * SS burst configuration parameters. 
% Note that the SS burst generation can be disabled by setting the 
% |SSBTransmitted| field to [0 0 0 0].

% Set waveform type and PDSCH numerology (SCS and CP type)
simParameters.NDLRB = 100;               % Bandwidth in number of resource blocks (20MHz at 15kHz SCS)
simParameters.SubcarrierSpacing = 15;    % 15, 30, 60, 120, 240, 480 (kHz)
simParameters.WaveformType = 'CP-OFDM';  % 'CP-OFDM', 'W-OFDM' or 'F-OFDM' 
simParameters.CyclicPrefix = 'Normal';   % 'Normal' or 'Extended'
simParameters.UseDCSubcarrier = 'On';    % 'On' or 'Off'
simParameters.NCellID = 1;               % Cell identity

% DL-SCH/PDSCH parameters
simParameters.PDSCH.TargetCodeRate = 0.5;    % Code rate used to calculate transport block sizes
simParameters.PDSCH.CodingType = 'LDPC';     % Set to 'LDPC' for 5G DL-SCH or 'Turbo' for LTE DL-SCH
simParameters.PDSCH.PRBSet = 8:15;           % PDSCH PRB allocation
simParameters.PDSCH.SymbolSet = 0:13;        % PDSCH symbol allocation in slot
simParameters.PDSCH.Modulation = '16QAM';    % 'QPSK', '16QAM', '64QAM', '256QAM'
simParameters.PDSCH.NLayers = 2;             % Number of PDSCH layers
simParameters.PDSCH.NTxAnts = 8;             % Number of PDSCH transmission antennas
simParameters.PDSCH.EnableHARQ = true;       % Enable/disable HARQ, if disabled, single transmission with RV=0, i.e. no retransmissions
% DM-RS configuration (TS 38.211 section 7.4.1.1)
simParameters.PDSCH.PortSet = [0,2];         % DM-RS ports to use for the layers
simParameters.PDSCH.PDSCHMappingType = 'A';  % PDSCH mapping type ('A'(slot-wise),'B'(non slot-wise))
simParameters.PDSCH.DL_DMRS_typeA_pos = 2;   % Mapping type A only. First DM-RS symbol position (2,3)
simParameters.PDSCH.DL_DMRS_max_len = 1;     % Number of front-loaded DM-RS symbols (1(single symbol),2(double symbol))              
simParameters.PDSCH.DL_DMRS_add_pos = 0;     % Additional DM-RS symbol positions (max range 0...3)
simParameters.PDSCH.DL_DMRS_config_type = 2; % DM-RS configuration type (1,2)
simParameters.PDSCH.NIDNSCID = 1;            % Scrambling identity (0...65535)
simParameters.PDSCH.NSCID = 0;               % Scrambling initialization (0,1)
% Reserved PRB patterns (for CORESETs, forward compatibility etc)
simParameters.PDSCH.Reserved.Symbols = [];   % Reserved PDSCH symbols
simParameters.PDSCH.Reserved.PRB = [];       % Reserved PDSCH PRBs
simParameters.PDSCH.Reserved.Period = [];    % Periodicity of reserved resources

% Define the propagation channel type and number of receive antennas
simParameters.ChannelType = 'CDL'; % 'CDL' or 'TDL'
simParameters.NRxAnts = 2;         % Number of receive antennas at UE

% SS burst configuration
simParameters.SSBurst.BurstType = 'CaseB';        % 30kHz subcarrier spacing
simParameters.SSBurst.SSBTransmitted = [0 1 0 1]; % Bitmap indicating blocks transmitted in the burst
simParameters.SSBurst.SSBPeriodicity = 20;        % SS burst set periodicity in ms (5, 10, 20, 40, 80, 160)

%%
% Additional parameters can be set depending on the type of modulation
% waveform used. 
%
% For W-OFDM you can specify:
% 
% * The window roll-off factor
% * The windowing function samples. This parameter is optional and defaults
% to root raised cosine if unspecified
%
% For F-OFDM you can specify:
%
% * The filter length
% * The tone offset
%
% For more information on how to parameterize the different waveforms see
% the help for <matlab:help('h5gOFDMModulate') h5gOFDMModulate> and 
% [ <#14 5> ].

% W-OFDM specific parameters
simParameters.Alpha = 0.0125;

% F-OFDM specific parameters
simParameters.FilterLength = 513;
simParameters.ToneOffset = 2.5;

%%
% Calculate the 5G standard defined TBS, given the PDSCH configuration

% Create gNodeB configuration structure 'gnb' and PDSCH configuration
% structure 'pdsch'
gnb = simParameters;
pdsch = simParameters.PDSCH;

% Get PDSCH resourcing information
[~,~,~,pdschIndicesInfo] = h5gPDSCHResources(gnb,pdsch);

Xoh_PDSCH = 0;     % The Xoh-PDSCH overhead value is taken to be 0 here
tbs = h5gPDSCHTBS(pdsch,pdschIndicesInfo.NREPerPRB-Xoh_PDSCH);

% Create a vector of TBSs, one per group of 10 slots, since the HARQ
% processing in this example uses LTE oriented HARQ management code
trBlkSizes = tbs*ones(1,10);

%% Propagation Channel Model Configuration
% Create the channel model object. Both CDL and TDL channel models are
% supported [ <#14 6> ].

nTxAnts = simParameters.PDSCH.NTxAnts;
nRxAnts = simParameters.NRxAnts;

if strcmpi(simParameters.ChannelType,'CDL')
    channel = nr5gCDLChannel; % CDL channel object
    
    % Use CDL-C model (Urban macrocell model (R1-161736, R1-162960))
    channel.DelayProfile = 'CDL-C';
    channel.DelaySpread = 300e-9;
    
    % Turn the overall number of transmit antennas into a specific antenna
    % panel array geometry
    %
    % Table of antenna panel array configurations
    % M:  no. of rows in each antenna panel
    % N:  no. of columns in each antenna panel
    % P:  no. of polarizations (1 or 2)
    % Mg: no. of rows in the array of panels
    % Ng: no. of columns in the array of panels
    % Row format: [M  N   P   Mg  Ng]
    antarrays = ...  
        [1   1   1   1   1;   % 1 ants
         1   1   2   1   1;   % 2 ants
         2   1   2   1   1;   % 4 ants
         2   2   2   1   1;   % 8 ants
         2   4   2   1   1;   % 16 ants
         4   4   2   1   1;   % 32 ants
         4   4   2   1   2;   % 64 ants
         4   8   2   1   2;   % 128 ants
         4   8   2   2   2;   % 256 ants
         8   8   2   2   2;   % 512 ants
         8  16   2   2   2];  % 1024 ants    
     antselected = 1+fix(log2(nTxAnts));
     channel.TransmitAntennaArray.Size = antarrays(antselected,:);

    % Setup the receive antenna geometry
    if nRxAnts == 1
        % In the following settings, the number of rows in antenna array, 
        % columns in antenna array, polarizations, row array panels and the
        % columns array panels are all 1
        channel.ReceiveAntennaArray.Size = ones(1,5);
    else
        % In the following settings, the no. of rows in antenna array is
        % nRxAntennas/2, the no. of columns in antenna array is 1, the no.
        % of polarizations is 2, the no. of row array panels is 1 and the
        % no. of column array panels is 1. The values can be changed to
        % create alternative antenna setups
        channel.ReceiveAntennaArray.Size = [fix(nRxAnts/2),1,2,1,1];
    end
    
elseif strcmpi(simParameters.ChannelType,'TDL')
    channel = nr5gTDLChannel; % TDL channel object
    % Set the channel geometry
    channel.DelayProfile = 'TDL-C';
    channel.DelaySpread = 300e-9;
    channel.NumTransmitAntennas = nTxAnts;
    channel.NumReceiveAntennas = nRxAnts;
    channel.PathGainsOutputPort = true;  % Provide the path gains as an output
else
    error('ChannelType parameter field must be either CDL or TDL');
end

%%
% The sampling rate for the channel model is set using the value returned
% from <matlab:help('h5gOFDMInfo') h5gOFDMInfo>.

waveformInfo = h5gOFDMInfo(gnb);
channel.SampleRate = waveformInfo.SamplingRate;

%%
% Get the maximum number of delayed samples by a channel multipath
% component. This is calculated from the channel path with the largest
% delay and the implementation delay of the channel filter. This is
% required later to flush the channel filter to obtain the received signal.

chInfo = info(channel);
maxChDelay = ceil(max(chInfo.PathDelays*channel.SampleRate)) + chInfo.ChannelFilterDelay;

%% Reserve PDSCH Resources Corresponding to SS burst
% The figure below shows the signals and channels generated in the example.
%
% <<5GAddOnExampleWaveform.png>>
%
% This section shows how to reserve resources for the transmission of the
% SS burst.

% Create SS burst waveform and information structure and display a plot
% showing the SS burst content (in the SS burst numerology)
ssburst = simParameters.SSBurst;
ssburst.DisplayBurst = true;
[ssbWaveform,~,ssbInfo] = h5gSSBurst(gnb,ssburst);

% Demodulate SS burst waveform using data numerology - note that depending
% on subcarrier spacings, the SS burst content may not be orthogonal with
% the data subcarriers
ssbGrid = h5gOFDMDemodulate(gnb,ssbWaveform);

% Map the occupied subcarriers and transmitted symbols of the SS burst
% (defined in the SS burst numerology) to PDSCH PRBs and symbols in the
% data numerology
[mappedPRB,mappedSymbols] = mapNumerology(ssbInfo.OccupiedSubcarriers,ssbInfo.SymbolsTransmitted,ssbInfo.SubcarrierSpacing,gnb.SubcarrierSpacing);        

% Configure the PDSCH to reserve these resources so that the PDSCH
% transmission does not overlap the SS burst
reservation.Symbols = mappedSymbols;
reservation.PRB = mappedPRB;
reservation.Period = simParameters.SSBurst.SSBPeriodicity * waveformInfo.SymbolsPerSubframe;
pdsch.Reserved(end+1) = reservation;

% Create a plot showing the PDSCH, PDSCH DM-RS and SS burst resources
plotPDSCHResources(gnb,pdsch,ssbGrid);

%% Processing Loop
% To determine the throughput at each SNR point, the PDSCH data is analyzed
% per transmission instance using the following steps:
%
% * _Update current HARQ process._ The HARQ process either carries new
% transport data or a retransmission of previously sent transport data
% depending upon the acknowledgment (ACK) or negative acknowledgment
% (NACK). ACK or NACKs are not transmitted in this example, instead this is
% signaled using the CRC results. All this is handled by the HARQ
% scheduler, <matlab:edit('hHARQScheduling.m') hHARQScheduling.m>. The
% PDSCH data is updated based on the HARQ state.
%
% * _Resource grid generation._ The data generated by the HARQ process is
% channel coded and modulated on the PDSCH by <matlab:doc('h5gDLSCH')
% h5gDLSCH> and <matlab:doc('ltePDSCH') ltePDSCH>. The precoding operation
% is also performed in this step.
%
% * _Waveform generation._ The generated grid is then OFDM modulated.
%
% * _Noisy channel modeling._ The waveform is passed through a CDL or TDL
% fading channel. AWGN is added.
%
% * _Perform synchronization and OFDM demodulation._ Information returned
% by the channel is used for perfect synchronization. The synchronized
% signal is then OFDM demodulated.
%
% * _Perform perfect channel estimation._ Perfect channel estimation is
% used.
%
% * _Precoding matrix calculation._ The precoding matrix W for the next
% transmission is calculated using singular value decomposition (SVD). A
% single matrix is obtained for the full allocation by averaging the
% channel conditions. Therefore, for a channel with frequency selectivitiy,
% W could be less accurate for larger allocated bandwidths.
%
% * _Decode the PDSCH._ The recovered PDSCH symbols for all transmit and
% receive antenna pairs, along with a noise estimate, are demodulated and
% descrambled by <matlab:doc('h5gPDSCHDecode') h5gPDSCHDecode> to obtain an
% estimate of the received codewords. Note that this function is a modified
% version of <matlab:doc('ltePDSCHDecode') ltePDSCHDecode> which creates an
% LLR output which is compatible with the LDPC decoder used in the 5G
% DL-SCH decoding.
%
% * _Decode the Downlink Shared Channel (DL-SCH) and store the block CRC
% error for a HARQ process._ The vector of decoded soft bits is passed to
% <matlab:doc('h5gDLSCHDecode') h5gDLSCHDecode> which decodes the codeword
% and returns the block CRC error used to determine the throughput of the
% system. The contents of the updated soft buffer, |harqProc(harqIdx).decState|,
% are available at the output of this function to be used when decoding
% the next retransmission, if required.

% Initialize variables used in the simulation and analysis
% Array to store the maximum throughput for all SNR points
maxThroughput = zeros(length(simParameters.SNRIn),1); 
% Array to store the simulation throughput for all SNR points
simThroughput = zeros(length(simParameters.SNRIn),1);

% Specify additional required fields for PDSCH
pdsch.TxScheme = 'Port7-14'; 
pdsch.RNTI = 1;

% Set up Redundancy Version (RV) sequence, number of HARQ processes and
% the sequence in which the HARQ processes are used
if pdsch.EnableHARQ
    % In the final report of RAN WG1 meeting #91 (R1-1719301), it was
    % observed in R1-1717405 that if performance is the priority, [0 2 3 1]
    % should be used. If self-decodability is the priority, it should be
    % taken into account that the upper limit of the code rate at which
    % each RV is self-decodable is in the following order: 0>3>>2>1
    rvSeq = [0 2 3 1];
else
    % HARQ disabled - single transmission with RV=0, no retransmissions
    rvSeq = 0; 
end
pdsch.NHARQProcesses = 8;
harqSequence = 1:pdsch.NHARQProcesses;

for snrIdx = 1:numel(simParameters.SNRIn)

    % Set the random number generator settings to default values
    rng('default');
    
    SNRdB = simParameters.SNRIn(snrIdx);
    fprintf('\nSimulating transmission scheme 1 (%dx%d) and %s (SCS=%dkHz) with %s channel at %gdB SNR for %d 10ms frame(s)\n',...
        nTxAnts,nRxAnts,gnb.WaveformType,gnb.SubcarrierSpacing, ...
        simParameters.ChannelType,SNRdB,simParameters.NFrames); 
        
    % Initialize variables used in the simulation and analysis
    blkCRC = [];            % Block CRC for all active PDSCH transmissions
    bitTput = [];           % Number of successfully received bits per transmission
    txedTrBlkSizes = [];    % Number of transmitted info bits per transmission
    
    % Initialize the state of all HARQ processes
    pdsch.TrBlkSizes = trBlkSizes;
    gnb.PDSCH = pdsch;
    harqProcesses = hNewHARQProcess(gnb);
    
    % Reset the channel so that each SNR point will experience the same
    % channel realization
    reset(channel);
    
    % Total number of OFDM symbols in the simulation period
    NSymbols = simParameters.NFrames * 10 * waveformInfo.SymbolsPerSubframe;
    
    % OFDM symbol number associated with start of each PDSCH transmission
    gnb.NSymbol = 0;
    
    % Running counter of the number of PDSCH transmission instances
    % The simulation will use this counter as the slot number for each
    % PDSCH
    npdsch = 0;    
    
    % Index to the start of the current set of SS burst samples to be
    % transmitted. Also record which SS blocks in the burst are configured
    % for transmission, a bitmap of all zeros will be used to create a
    % waveform with the correct SSB periodicity
    ssbSampleIndex = 1;
    ssbTransmitted = ssburst.SSBTransmitted;
    ssburst.DisplayBurst = false;
    
    % Obtain a precoding matrix to be used in the transmission of the first
    % transport block
    estChannelGrid = getInitialChannelEstimate(gnb,pdsch,channel);    
    wtx = getPrecodingMatrix(pdsch,estChannelGrid);
    
    while  gnb.NSymbol < NSymbols        
        
        % Set the current slot number
        pdsch.NSlot = npdsch;
        
        % Generate a new SS burst when necessary
        if (ssbSampleIndex==1)
            nsf = gnb.NSymbol / waveformInfo.SymbolsPerSubframe;
            ssburst.SSBTransmitted = ssbTransmitted * (mod(nsf,simParameters.SSBurst.SSBPeriodicity)==0);
            ssburst.NHalfFrame = mod(nsf / 5,2);
            [ssbWaveform,~,ssbInfo] = h5gSSBurst(gnb,ssburst);
        end
        
        % Get HARQ process index for the current PDSCH from HARQ index table
        harqProcIdx = harqSequence(mod(npdsch,length(harqSequence))+1);

        % Update current HARQ process information
        harqProcesses(harqProcIdx) = hHARQScheduling(harqProcesses(harqProcIdx),npdsch,rvSeq);
        
        % Extract the current PDSCH transport block size
        trBlk = trBlkSizes(:, mod(npdsch,size(trBlkSizes,2))+1).';
               
        % Update the PDSCH transmission config from the HARQ process state
        pdsch = harqProcesses(harqProcIdx).txConfig;
        trdata = harqProcesses(harqProcIdx).data;

        % PDSCH resource element indices and PDSCH DM-RS
        [pdschIndices,dmrsIndices,dmrsSymbols,pdschIndicesInfo] = h5gPDSCHResources(gnb,pdsch);
        
        % Perform DL-SCH transport channel coding
        codedTrBlock = h5gDLSCH(gnb,pdsch,pdschIndicesInfo.G,trdata);
        
        % Use LTE PDSCH in beamforming mode to create the transmission
        % symbols, which requires some additional function-specific
        % parameters to be set
        gnb.CellRefP = 1;
        pdsch.W = wtx;
        % Update effective subframe number to be used to generate the LTE
        % PDSCH scrambling etc. For SCS > 15kHz (15kHz * 2^n) this will
        % compress the scrambling frame structure into periods of 1/(2^n)
        % milliseconds. The true 1ms subframe number will be:
        % fix(gnb.NSymbol/waveformInfo.symbolsPerSubframe)
        gnb.NSubframe = npdsch;
        pdschSymbols = ltePDSCH(gnb,pdsch,codedTrBlock);
        
        % PDSCH mapping in grid associated with PDSCH transmission period
        pdschGrid = zeros(waveformInfo.NSubcarriers,waveformInfo.SymbolsPerSlot,nTxAnts);
        [~,pdschAntIndices] = lteExtractResources(pdschIndices,pdschGrid);
        pdschGrid(pdschAntIndices) = pdschSymbols;
        
        % PDSCH DM-RS precoding and mapping
        for p = 1:size(dmrsSymbols,2)
            [~,dmrsAntIndices] = lteExtractResources(dmrsIndices(:,p),pdschGrid);
            pdschGrid(dmrsAntIndices) = pdschGrid(dmrsAntIndices) + dmrsSymbols(:,p) * wtx(p,:);
        end
      
        % OFDM modulation of associated resource elements
        txWaveform = h5gOFDMModulate(gnb, pdschGrid);
        
        % Add the appropriate portion of SS burst waveform to the
        % transmitted waveform
        Nt = size(txWaveform,1);
        txWaveform = txWaveform + ssbWaveform(ssbSampleIndex + (0:Nt-1),:);
        ssbSampleIndex = mod(ssbSampleIndex + Nt,size(ssbWaveform,1));

        % Pass data through channel model. Append zeros at the end of the
        % transmitted waveform to flush channel content. These zeros take
        % into account any delay introduced in the channel. This is a mix
        % of multipath delay and implementation delay. This value may 
        % change depending on the sampling rate, delay profile and delay
        % spread
        txWaveform = [txWaveform; zeros(maxChDelay, size(txWaveform,2))]; %#ok<AGROW>
        [rxWaveform,pathGains] = channel(txWaveform);
        
        % Calculate linear noise gain
        SNR = 10^(SNRdB/20);

        % Normalize noise power to take account of sampling rate, which is
        % a function of the IFFT size used in OFDM modulation
        N0 = 1/(sqrt(2.0*double(waveformInfo.Nfft))*SNR);

        % Create additive white Gaussian noise
        noise = N0*complex(randn(size(rxWaveform)),randn(size(rxWaveform)));

        % Add AWGN to the received time domain waveform        
        rxWaveform = rxWaveform + noise;

        % Perfect synchronization. Use information provided by the channel
        % to find the strongest multipath component
        [offset,mag] = h5gPerfectTimingOffset(pathGains,chInfo,waveformInfo.SamplingRate);
        rxWaveform = rxWaveform(1+offset:end, :);

        % Perform OFDM demodulation on the received data to recreate the
        % resource grid
        rxGrid = h5gOFDMDemodulate(gnb, rxWaveform);

        % Perfect channel estimation, use the value of the path gains
        % provided by the channel
        % Get estimates for the transmission period of LTE PDSCH instance 
        % (in terms of symbols, this is equivalent to an LTE subframe)
        estChannelGrid = h5gPerfectChannelEstimate(gnb,channel,pathGains,offset);
        
        % Noise estimation directly from the noise realization
        noiseGrid = h5gOFDMDemodulate(gnb, noise(1+offset:end ,:));
        noiseEst = var(noiseGrid(:));
        
        wtx = getPrecodingMatrix(pdsch,estChannelGrid);
        
        % Apply precoding to Hest
        % Linearize 4D matrix and reshape after multiplication
        K = size(estChannelGrid,1);
        Hest = reshape(estChannelGrid,K*waveformInfo.SymbolsPerSlot*nRxAnts,nTxAnts);
        Hest = Hest*pdsch.W.';
        Hest = reshape(Hest,K,waveformInfo.SymbolsPerSlot,nRxAnts,pdsch.NLayers);
        
        % Get PDSCH resource elements from the received grid
        [pdschRx,pdschHest] = lteExtractResources(pdschIndices,rxGrid,Hest);
        
        % Decode LTE PDSCH physical channel
        % This uses a modified version of ltePDSCHDecode which creates 
        % an LLR output which is compatible with the LDPC decoder used in
        % the 5G DL-SCH decoding
        [dlschBits,rxSymbols] = h5gPDSCHDecode(gnb,pdsch,pdschRx,pdschHest,noiseEst);     
        
        % Decode the DL-SCH transport channel
        [decbits,harqProcesses(harqProcIdx).blkerr,harqProcesses(harqProcIdx).decState] = ...
            h5gDLSCHDecode(gnb,pdsch,trBlk,dlschBits,harqProcesses(harqProcIdx).decState);
              
        % Store values to calculate throughput (only for active PDSCH instances)
        if(any(trBlk) ~= 0)
            blkCRC = [blkCRC harqProcesses(harqProcIdx).blkerr];                %#ok<AGROW>
            bitTput = [bitTput trBlk.*(1-harqProcesses(harqProcIdx).blkerr)];   %#ok<AGROW>
            txedTrBlkSizes = [txedTrBlkSizes trBlk];                            %#ok<AGROW>
        end
        
        % Update starting symbol number of next PDSCH transmission
        gnb.NSymbol = gnb.NSymbol + size(pdschGrid,2);
        % Update count of overall number of PDSCH transmissions
        npdsch = npdsch + 1;
        
        % Display transport block error information per codeword managed by current HARQ process
        fprintf('\n(%3.2f%%) HARQ Proc %d: ', 100*gnb.NSymbol/NSymbols,harqProcIdx);
        estrings = {'passed','failed'};
        rvi = harqProcesses(harqProcIdx).txConfig.RVIdx; 
        for cw=1:length(rvi)
            cwrvi = rvi(cw);
            % Create a report on the RV state given position in RV sequence and decoding error
            if cwrvi == 1
                ts = sprintf('Initial transmission (RV=%d)',rvSeq(cw,cwrvi));
            else
                ts = sprintf('Retransmission #%d (RV=%d)',cwrvi-1,rvSeq(cw,cwrvi));
            end
            fprintf('CW%d - %s %s. ',cw-1,ts,estrings{1+harqProcesses(harqProcIdx).blkerr(cw)});          
        end
         
     end
    
    % Calculate maximum and simulated throughput
    maxThroughput(snrIdx) = sum(txedTrBlkSizes); % Max possible throughput
    simThroughput(snrIdx) = sum(bitTput,2);      % Simulated throughput
    
    % Display the results dynamically in the command window
    fprintf([['\n\nThroughput(Mbps) for ', num2str(simParameters.NFrames) ' frame(s) '],...
        '= %.4f\n'], 1e-6*simThroughput(snrIdx)/(simParameters.NFrames*10e-3*(2/waveformInfo.SlotsPerSubframe)));
    fprintf(['Throughput(%%) for ', num2str(simParameters.NFrames) ' frame(s) = %.4f\n'],...
        simThroughput(snrIdx)*100/maxThroughput(snrIdx));
     
end

%% Results
% Display the measured throughput. This is calculated as the percentage of
% the maximum possible throughput of the link given the available resources
% for data transmission.

figure;
plot(simParameters.SNRIn,simThroughput*100./maxThroughput,'o-.')
xlabel('SNR (dB)'); ylabel('Throughput (%)'); grid on;
title(sprintf('%s / (%dx%d) / %s / NDLRB=%d / SCS=%dkHz',...
               pdsch.CodingType,nTxAnts,nRxAnts,gnb.WaveformType, ...
               gnb.NDLRB,gnb.SubcarrierSpacing));

% Bundle key parameters and results into a combined structure for recording
simResults.simParameters = simParameters;
simResults.simThroughput = simThroughput;

%%
% The figure below shows the throughput obtained when simulating 1000
% frames.
%
% <<nr5gLongRunThroughput.png>>
%
%% Appendix
%
% This example uses the following helper functions:
%
% * <matlab:edit('hNewHARQProcess.m') hNewHARQProcess.m>
% * <matlab:edit('hHARQScheduling.m') hHARQScheduling.m>
% * <matlab:edit('h5gOFDMModulate.m') h5gOFDMModulate.m>
% * <matlab:edit('h5gOFDMDemodulate.m') h5gOFDMDemodulate.m>
% * <matlab:edit('h5gOFDMInfo.m') h5gOFDMInfo.m>
% * <matlab:edit('h5gDLSCHInfo.m') h5gDLSCHInfo.m>
% * <matlab:edit('h5gPDSCHTBS.m') h5gPDSCHTBS.m>
% * <matlab:edit('h5gPDSCHResources.m') h5gPDSCHResources.m>
% * <matlab:edit('h5gDLSCH.m') h5gDLSCH.m>
% * <matlab:edit('h5gDLSCHDecode.m') h5gDLSCHDecode.m>
% * <matlab:edit('h5gPDSCHDecode.m') h5gPDSCHDecode.m>
% * <matlab:edit('h5gCodeBlockSegment.m') h5gCodeBlockSegment.m>
% * <matlab:edit('h5gCodeBlockDesegment.m') h5gCodeBlockDesegment.m>
% * <matlab:edit('h5gLDPCEncode.m') h5gLDPCEncode.m>
% * <matlab:edit('h5gLDPCDecode.m') h5gLDPCDecode.m>
% * <matlab:edit('h5gRateMatchLDPC.m') h5gRateMatchLDPC.m>
% * <matlab:edit('h5gRateRecoverLDPC.m') h5gRateRecoverLDPC.m>
% * <matlab:edit('h5gLDPCParityCheckMatrix.m') h5gLDPCParityCheckMatrix.m>
% * <matlab:edit('h5gSSBurst.m') h5gSSBurst.m>
% * <matlab:edit('h5gPerfectTimingOffset.m') h5gPerfectTimingOffset.m>
% * <matlab:edit('h5gPerfectChannelEstimate.m') h5gPerfectChannelEstimate.m>

%% Selected Bibliography
% # 3GPP TS 38.211 V15.0 "NR; Physical channels and modulation"
% # 3GPP TS 38.212 V15.0 "NR; Multiplexing and channel coding"
% # 3GPP TS 38.213 V15.0 "NR; Physical layer procedures for control"
% # 3GPP TS 38.214 V15.0 "NR; Physical layer procedures for data"
% # R1-166999, "Detailed configuration of F-OFDM and W-OFDM for LLS
% evaluation", Spreadtrum Communications, 3GPP RAN WG1 #86, August 2016
% # 3GPP TR 38.901 V14.3 "Study on channel model for frequencies from 0.5 to 100 GHz"

displayEndOfDemoMessage(mfilename)

function estChannelGrid = getInitialChannelEstimate(gnb,pdsch,channel)

    ofdmInfo = h5gOFDMInfo(gnb);
    sr =       ofdmInfo.SamplingRate;
    
    chInfo = info(channel);
    maxChDelay = ceil(max(chInfo.PathDelays*channel.SampleRate)) + chInfo.ChannelFilterDelay;
    
    % Temporary waveform (only needed for the sizes)
    tmpWaveform = zeros((ofdmInfo.SamplesPerSubframe/ofdmInfo.SlotsPerSubframe)+maxChDelay,pdsch.NTxAnts);
    
    % Filter through channel    
    [~,pathGains] = channel(tmpWaveform);
    
    % Perfect timing synch
    offset = h5gPerfectTimingOffset(pathGains,chInfo,sr);
    
    % Perfect channel estimate
    estChannelGrid = h5gPerfectChannelEstimate(gnb,channel,pathGains,offset);
    
end

function wtx = getPrecodingMatrix(pdsch,hestGrid)
    
    % Allocated subcarrier indices
    allocSc = (1:12)' + 12*pdsch.PRBSet(:).';
    allocSc = allocSc(:);
    
    % Average channel estimate
    [~,~,R,P] = size(hestGrid);
    estAllocGrid = hestGrid(allocSc,:,:,:);
    Hest = permute(mean(reshape(estAllocGrid,[],R,P)),[2 3 1]);
    
    % SVD decomposition
    [~,~,V] = svd(Hest);
    wtx = V(:,1:pdsch.NLayers).';

end

function [mappedPRB,mappedSymbols] = mapNumerology(subcarriers,symbols,fs,ft)

    mappedPRB = unique(fix(subcarriers*fs/(ft*12)),'stable');
    
    if (ft < fs)
        % If ft/fs < 1, reduction
        mappedSymbols = unique(fix(symbols*ft/fs),'stable');
    else
        % Else, repetition by ft/fs
        mappedSymbols = reshape((0:(ft/fs-1))' + symbols(:)'*ft/fs,1,[]);
    end
    
end

function plotPDSCHResources(gnb,pdsch,ssbGrid)
    
    % Create an empty resource grid spanning one slot
    waveformInfo = h5gOFDMInfo(gnb);
    grid = zeros(waveformInfo.NSubcarriers,waveformInfo.SymbolsPerSlot,pdsch.NLayers);
    
    % Trim the SS burst grid to contain the same number of OFDM symbols
    ssbGrid= ssbGrid(:,1:size(grid,2));
    
    % Create PDSCH and PDSCH DM-RS indices
    [pdschIndices,pdschDmrsIndices] = h5gPDSCHResources(gnb,pdsch);
    
    % Mark PDSCH and PDSCH DM-RS positions in the grid
    grid(pdschIndices) = 2;
    grid(pdschDmrsIndices) = 3;
    
    % Mark SS burst positions in the grid
    grid(abs(ssbGrid)>=0.5) = grid(abs(ssbGrid)>=0.5) + 1;
    grid(abs(ssbGrid)<0.5 & abs(ssbGrid)>=0.1) = grid(abs(ssbGrid)<0.5 & abs(ssbGrid)>=0.1) + 0.3;
    grid(abs(ssbGrid)<0.1 & abs(ssbGrid)>0.03) = grid(abs(ssbGrid)<0.1 & abs(ssbGrid)>0.03) + 0.1;
    
    % Plot the grid
    figure;
    imagesc(abs(grid(:,:,1)));
    axis xy;
    
    % Create a legend for the different channels / signals, this is
    % achieved by drawing off-plot patches with the appropriate colors
    % then adding a legend
    hold on;
    patch([-2 -3 -3 -2],[-2 -2 -3 -3],1);
    patch([-2 -3 -3 -2],[-2 -2 -3 -3],2);
    patch([-2 -3 -3 -2],[-2 -2 -3 -3],3);
    legend('SS burst','PDSCH','PDSCH DM-RS');
    
    % Add axis labels and title
    ylabel('Subcarriers');
    xlabel('OFDM symbols');
    title(sprintf('PDSCH / DM-RS / SS burst, SCS=%dkHz, NDLRB=%d, Port=%d',gnb.SubcarrierSpacing,gnb.NDLRB,1000 + pdsch.PortSet(1)));
    drawnow;
    
end

##### SOURCE END #####
--></body></html>